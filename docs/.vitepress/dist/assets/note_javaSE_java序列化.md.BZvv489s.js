import{_ as a,c as t,a2 as o,o as r}from"./chunks/framework.DX8ksQZH.js";const u=JSON.parse('{"title":"java序列化","description":"","frontmatter":{"title":"java序列化","outline":"deep"},"headers":[],"relativePath":"note/javaSE/java序列化.md","filePath":"note/javaSE/java序列化.md","lastUpdated":1729326578000}'),i={name:"note/javaSE/java序列化.md"};function c(d,e,l,n,s,p){return r(),t("div",null,e[0]||(e[0]=[o('<h1 id="java序列化" tabindex="-1">java序列化 <a class="header-anchor" href="#java序列化" aria-label="Permalink to &quot;java序列化&quot;">​</a></h1><blockquote><p>作者: 小王</p><p>状态: 稳定</p><p>✌️👀✌️</p></blockquote><h2 id="什么是序列化和反序列化" tabindex="-1">什么是序列化和反序列化 <a class="header-anchor" href="#什么是序列化和反序列化" aria-label="Permalink to &quot;什么是序列化和反序列化&quot;">​</a></h2><p><strong>序列化</strong>: 将java对象转为字节流</p><p><strong>反序列化</strong>: 将字节流重新转为java对象</p><h2 id="涉及到的类" tabindex="-1">涉及到的类 <a class="header-anchor" href="#涉及到的类" aria-label="Permalink to &quot;涉及到的类&quot;">​</a></h2><p>序列化: <code>ObjectOutputStream</code></p><p>反序列化: <code>ObjectInputStream</code></p><h2 id="关键信息" tabindex="-1">关键信息 <a class="header-anchor" href="#关键信息" aria-label="Permalink to &quot;关键信息&quot;">​</a></h2><h3 id="序列化前提-serializable" tabindex="-1">序列化前提-Serializable <a class="header-anchor" href="#序列化前提-serializable" aria-label="Permalink to &quot;序列化前提-Serializable&quot;">​</a></h3><p>如果想要一个类可以被序列化, 那么这个类必须实现<code>Serializable</code>接口, 同时该类的所有属性字段也都必须是实现了<code>Serializable</code>接口的类(包括包装类)</p><h3 id="排除字段-transient" tabindex="-1">排除字段-transient <a class="header-anchor" href="#排除字段-transient" aria-label="Permalink to &quot;排除字段-transient&quot;">​</a></h3><p>如果不希望类的某个字段被序列化, 可以用<code>transient</code>关键字标记该字段</p><p>其次, static属性字段也不会被序列化</p><h3 id="序列化方式-objectoutputstream" tabindex="-1">序列化方式-ObjectOutputStream <a class="header-anchor" href="#序列化方式-objectoutputstream" aria-label="Permalink to &quot;序列化方式-ObjectOutputStream&quot;">​</a></h3><p>调用<code>objectOutputStream.writeObject(Object o);</code>方法将对象序列化为字节流, 该方法会序列化未被<code>transient</code>和<code>staic</code>修饰的属性字段</p><h3 id="自定义序列化-writeobject" tabindex="-1">自定义序列化-writeObject <a class="header-anchor" href="#自定义序列化-writeobject" aria-label="Permalink to &quot;自定义序列化-writeObject&quot;">​</a></h3><p>可以通过在需要序列化的类中定义<code>writeObject</code>方法来实现自定义序列化内容, 例如自定义<code>transient</code>字段的序列化方式</p><p>可以在该方法内部调用<code>defaultWriteObject</code>方法来序列化默认会被序列化的字段(实际上如果不写本方法,默认调用的就是<code>defaultWriteObject</code>方法来序列化), 然后对<code>transient</code>修饰的属性进行自定义序列化</p><h3 id="序列化校验-serialversionuid" tabindex="-1">序列化校验-serialVersionUID <a class="header-anchor" href="#序列化校验-serialversionuid" aria-label="Permalink to &quot;序列化校验-serialVersionUID&quot;">​</a></h3><ul><li><p><strong><code>serialVersionUID</code>是什么?</strong></p><p>当一个类实现了<code>Serializable</code>接口后, 默认会隐式拥有一个<code>serialVersionUID</code>字段, 该字段表示该类的版本,每当我们修改该类的属性结构, 例如添加, 删除一个属性, 该<code>serialVersionUID</code>的值都会改变</p></li><li><p><strong>显式添加<code>serialVersionUID</code>的意义?</strong></p><p>在不显示添加<code>serialVersionUID</code>的情况下, 假设一个A类可序列化,进行了若干次序列化后,给A类的代码定义中添加了一个属性字段,这时由于<code>serialVersionUID</code>值发生了变化, 反序列化就会失败</p><p>显示添加<code>serialVersionUID</code>字段可以保证该字段值就是我们指定的值, 不会随着属性结构变化而变化, 以此保证反序列化的安全性</p></li></ul>',21)]))}const b=a(i,[["render",c]]);export{u as __pageData,b as default};
