import{_ as a,c as l,a2 as i,o as e}from"./chunks/framework.DX8ksQZH.js";const u=JSON.parse('{"title":"HTTPS","description":"","frontmatter":{"title":"HTTPS","outline":"deep"},"headers":[],"relativePath":"note/java_web_basic/https.md","filePath":"note/java_web_basic/https.md","lastUpdated":1727870653000}'),p={name:"note/java_web_basic/https.md"};function o(r,t,s,n,h,c){return e(),l("div",null,t[0]||(t[0]=[i('<h1 id="https" tabindex="-1">https <a class="header-anchor" href="#https" aria-label="Permalink to &quot;https&quot;">​</a></h1><blockquote><p>作者: 小王</p><p>状态: 稳定</p><p>✌️👀✌️</p></blockquote><p>尝试循序渐进解释一下https安全通信的原理</p><p>首先需要知道请求报文和相应报文在网络中进行明文转发是很危险的,很容易被窃取数据</p><p>因此, 我们的需要对明文进行加密</p><h2 id="对称加密" tabindex="-1">对称加密 <a class="header-anchor" href="#对称加密" aria-label="Permalink to &quot;对称加密&quot;">​</a></h2><p>客户端和服务器持有一个共同的密钥(会话密钥),该密钥可以对明文进行加密和解密</p><p><strong>通信流程</strong>:</p><p>请求: 客户端: 明文-&gt;密钥-&gt;密文;服务器: 密文-&gt;密钥-&gt;明文</p><p>响应: 服务器: 明文-&gt;密钥-&gt;密文;客户端: 密文-&gt;密钥-&gt;明文</p><p><strong>问题</strong>: 客户端和服务器需要安全地共享密钥,如果客户端生成密钥并直接将密钥发送给服务器,那么这个密钥极容易在网络传输中被窃取</p><h2 id="非对称加密" tabindex="-1">非对称加密 <a class="header-anchor" href="#非对称加密" aria-label="Permalink to &quot;非对称加密&quot;">​</a></h2><p>服务端持有一个公钥和一个私钥,公钥只能加密,私钥可以加密,也可以解密</p><p><strong>通信流程</strong>:</p><ul><li>客户端与服务器建立连接时,服务器先将公钥发送给客户端</li><li>客户端临时生成一个随机密钥,将该密钥使用公钥加密发送给服务器</li><li>服务器使用私钥解密,得到密钥</li><li>客户端和服务器使用该密钥(会话密钥)进行通信</li></ul><p>因为密钥在客户端临时生成, 通过公钥加密,而只有私钥才能解密,保证了会话密钥在网络传输中不会被窃取</p><p><strong>问题</strong>:</p><p>在第一次客户端获取公钥的时候,攻击者服务器可以截取该公钥,然后分别与客户端和服务器建立连接,提供给客户端一个虚假公钥,客户端用该虚假公钥加密了密钥,攻击者服务器可以用其自己的私钥解密,从而窃取了密钥</p><p>这里的问题出在: 客户端无法确认公钥来源的可靠性</p><h2 id="数字签名" tabindex="-1">数字签名 <a class="header-anchor" href="#数字签名" aria-label="Permalink to &quot;数字签名&quot;">​</a></h2><p>在解决问题之前先了解一下数字签名</p><p>数字签名用于验证数字的真实性和完整性,并不用于加密数据</p><p><strong>工作流程</strong>:</p><ul><li>原始消息 通过哈希函数生成消息摘要</li><li>签名者使用私钥对消息摘要加密得到数字签名</li><li>签名者将数字签名和原消息一起发给接收者</li><li>接收者对接收到的原始消息使用哈希函数加密得到消息摘要1,并使用签名者提供的公钥解密数字签名得到消息摘要2</li><li>接收者对比解密得到的消息摘要和自己重新计算出的消息摘要。如果两者相同则说明:消息在传输过程中没有被篡改, 数字签名确实是由签名者生成的</li></ul><h2 id="ca证书" tabindex="-1">CA证书 <a class="header-anchor" href="#ca证书" aria-label="Permalink to &quot;CA证书&quot;">​</a></h2><p>CA即证书颁发机构</p><p>服务器可以将自己的信息,以及公钥发给CA机构,CA机构对服务器进行认证后,生成该服务器的证书返还给服务器,证书中包括:</p><ul><li>服务器的公钥。</li><li>服务器的域名信息。</li><li>证书的有效期。</li><li>证书的数字签名</li></ul><p>在此之后,每一次请求流程如下:</p><ul><li>服务器需要先将证书发送给客户端</li><li>客户端操作系统或者浏览器中保存了根证书库, 从根证书库中找到相应的CA根证书，然后验证服务器证书的数字签名,认证成功后,说明该证书有效,证书内的服务器公钥也有效</li><li>接下来就可以进行上面说的非对称加密通信了</li></ul><h2 id="https总结" tabindex="-1">HTTPS总结 <a class="header-anchor" href="#https总结" aria-label="Permalink to &quot;HTTPS总结&quot;">​</a></h2><ol><li><strong>身份验证</strong>：通过CA颁发的数字证书，客户端能够确认服务器的身份，防止中间人攻击。</li><li><strong>加密通信</strong>：使用非对称加密安全地交换会话密钥，确保会话密钥不会被窃取。</li><li><strong>数据完整性</strong>：数字签名保证数据在传输中未被篡改。</li></ol>',32)]))}const g=a(p,[["render",o]]);export{u as __pageData,g as default};
